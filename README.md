# HTTP Web Server with Async-IO

### How to run:

```bash
$ cargo run
```

### Explanation:

`main.rs` starts the server and listens on port 6000.

All requests are routed through a handler provided in `main.rs`. A simple route matcher (provided in `path_utils.rs`) simplifies separating requests for the REST API based on path and query params.

The server itself creates and manages several `TcpStream`s generated by the `mio` library. The streams are passed to a wrapper `Connection` (in `connection.rs`). The streams are non-blocking and many can be created concurrently. The server does a blocking `poll` until events come in. Each connection first waits for the stream to become `readable`, parses and stores the buffer, then waits for the stream to become `writable`.

Once we have all the components we need, the buffer is parsed and HTTP `Request` and `Response` objects are created (provided by the `http` library (only provides types, no parsing)). These objects are passed to the handler provided in `main.rs` and the outgoing response is generated.

`serde` and `serde_json` are used for deserializing and storing the body of the post requests. If data is sent that doesn't exactly match the format outlined a `400` is returned.

-   `404`'s are returned for routes that we don't support.
-   `400`'s is returned with a reason if some condition is failed, eg:

    -   requesting messages for a chat that doesn't exist
    -   starting a chat with someone not in the contact list

-   `500`'s are returned if there's some other error we can't reasonably return a client error for

TODO: A million improvements. Better error handling, performance improvements (partial reads from socket), better ergonomics with async/await, timeouts, improved logging, testing, etc...
